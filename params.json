{"name":"Dispatch","tagline":"dispatch php 5.3 utility library","body":"Dispatch PHP 5.3+ Micro-framework\r\n=================================\r\nDispatch is a PHP micro-framework. It provides 29 short and easy functions that wrap commonly-used tasks in creating a web app. At the very least, Dispatch provides you with URL routing and view rendering.\r\n\r\n## Requirements\r\n* PHP 5.3+\r\n* `mcrypt` extension if you want to use encrypted cookies and wish to use `encrypt()` and `decrypt()` functions\r\n* `apc` extension if you want to use `cache()` and `cache_invalidate()`\r\n\r\n## Installation\r\nDispatch can be installed by using `composer`. In your `composer.json` file, do the following:\r\n\r\n```javascript\r\n{\r\n  \"require\": {\r\n    \"php\": \">= 5.3.0\",\r\n    ...\r\n    \"dispatch/dispatch\": \"*\",\r\n  }\r\n}\r\n```\r\n\r\nAfter adding the appropriate `require` entries, do a `composer install` or `composer update` to install the package.\r\n\r\nIf you don't use `composer`, you can download and include [src/dispatch.php](https://github.com/noodlehaus/dispatch/raw/master/src/dispatch.php) directly in your application.\r\n\r\nNote that Dispatch functions are all loaded into the global namespace.\r\n\r\n## Configuration Variables\r\n\r\nCertain properties and behaviours of Dispatch can be configured via the following `config()` entries:\r\n\r\n* `config('source', 'inifile.ini')` makes the contents of `inifile.ini` accessible via `config()` calls\r\n* `config('site.url')` optional setting for specifying your application's full URL (host and path)\r\n* `config('site.router')` if present, will be stripped from the request URI. useful if you don't have mod_rewrite\r\n* `config('views.root')` is used by `render()` and `partial()`, defaults to `./views`\r\n* `config('views.layout')` is used by `render()`, defaults to `layout`\r\n* `config('cookies.secret')` encryption salt to be used by `encrypt()`, `decrypt()`, `set\\_cookie()` and `get\\_cookie()`\r\n* `config('cookies.flash')` cookie name to be used by `flash()` for setting messages\r\n\r\n## URL Routing\r\nDispatch supports the `GET`, `POST`, `PUT`, `DELETE`, and `HEAD` request methods. To create routes for these methods, you can either use their equivalent convenience functions or call `route()` directly.\r\n\r\n```php\r\n<?php\r\n// get route for index\r\nget('/index', function () {\r\n  echo \"hello, world!\\n\";\r\n});\r\n\r\n// this is the same as above\r\nroute('GET', '/index', function () {\r\n  echo \"hello, world!\\n\";\r\n});\r\n\r\n// other routing functions are\r\n// post()\r\n// put()\r\n// delete()\r\n// head()\r\n```\r\n\r\n## URL Rewriting and Stripping\r\nSetting `site.router` to a string will strip that string from the URI before it is routed. Two use cases for this are when you don't have access to URI rewriting on your server, and if your dispatch application resides in a subdirectory.\r\n\r\n```php\r\n<?php\r\n// example 1: want to strip the index.php part from the URI\r\nconfig('site.router', 'index.php');\r\n\r\nget('/users', function () {\r\n  echo \"listing users...\";\r\n});\r\n\r\n// requested URI = /index.php/users\r\n// response = \"listing users...\"\r\n\r\n// example 2: our app lives in /mysite\r\nconfig('routing.base', 'mysite');\r\n\r\nget('/users', function () {\r\n  echo \"listing users...\";\r\n});\r\n\r\n// requested URI = /mysite/users\r\n// response = \"listing users...\"\r\n?>\r\n```\r\n\r\n## RESTful Objects\r\nIf you have a class that supports all or some of the default REST actions, you can easily publish them using `restify()`. By default, `restify()` will create all REST routes for your class. You can selectively publish actions by passing them to the function. To make a class support `restify()`, you need to implement some or all of the following methods:\r\n\r\n* `onIndex` - for the resource list\r\n* `onNew` - for the resource creation form\r\n* `onCreate` - for the creation action\r\n* `onShow($id)` - for viewing a resource\r\n* `onEdit($id)` - for the resource edit form\r\n* `onUpdate($id)` - for the resource edit action\r\n* `onDelete($id)` - for the resource delete action\r\n\r\nNote that the routes published by `restify()` uses the symbol `:id` to identify the resource.\r\n\r\n```php\r\n// resource to publish\r\nclass Users {\r\n  public function onIndex() {}\r\n  public function onNew() {}\r\n  public function onCreate() {}\r\n  public function onShow($id) {}\r\n  public function onEdit($id) {}\r\n  public function onUpdate($id) {}\r\n  public function onDelete($id) {}\r\n}\r\n\r\n// publish the instance, with all endpoints, under /users\r\nrestify('/users', new Users());\r\n\r\n// resource with just some of the REST endpoints\r\nclass Pages {\r\n  public function onIndex() {\r\n    echo \"Pages::onIndex\\n\";\r\n  }\r\n  public function onShow($id) {\r\n    echo \"Pages::onShow {$id}\\n\";\r\n  }\r\n}\r\n\r\n// publish object under /pages, but with just the available actions\r\nrestify('/pages', new Pages(), array('index', 'show'));\r\n?>\r\n```\r\n\r\n## DELETE and PUT Request Overrides\r\nUntil browsers provide support for DELETE and PUT methods in their forms, you can instead use a `hidden` `input` field named `\\_method` to override the request method for your form.\r\n\r\n```html\r\n<!-- sample PUT request -->\r\n<form method=\"POST\" action=\"/users/1\">\r\n  <input type=\"hidden\" name=\"_method\" value=\"PUT\">\r\n  ...\r\n  <input type=\"submit\" value=\"Update\">\r\n</form>\r\n\r\n<!-- sample DELETE request -->\r\n<form method=\"POST\" action=\"/users/1\">\r\n  <input type=\"hidden\" name=\"_method\" value=\"DELETE\">\r\n  ...\r\n  <input type=\"submit\" value=\"Remove\">\r\n</form>\r\n```\r\n\r\n## PUT Requests and JSON Requests\r\nIn cases where you're handling PUT requests or JSON posts and you need access to the raw http request body contents, you can use `request_body()` for this. The `request_body()` function will return an associative array containing the body's `content-type`, `content-length`, `content-parsed` and `content-raw`.\r\n\r\nThe `request_body()` function accepts an optional parameter, which should be a `callable` that takes three arguments - content type, length and raw data. This callable will be treated as the parser for the data and whatever it returns will be used by `request_body()` as the value for `content-parsed`.\r\n\r\n```php\r\nput('/users/:id', function ($id) {\r\n  $data = request_body();\r\n  // or\r\n  $data = request_body(function ($type, $length, $raw) {\r\n    return json_decode($raw);\r\n  });\r\n  /**\r\n  $data will be a hash of this structure\r\n  array(\r\n    'content-type' => 'content/type-here',\r\n    'content-length' => 123,\r\n    'content-parsed' => 'some data',\r\n    'content-raw' => 'raw data'\r\n  )\r\n  */\r\n});\r\n```\r\n\r\n## Route Symbol Filters\r\nThis is taken from ExpressJS. Route filters let you map functions against symbols in your routes. These functions then get executed when those symbols are matched.\r\n\r\n```php\r\n<?php\r\n// preload blog entry whenever a matching route has :blog_id in it\r\nfilter('blog_id', function ($blog_id) {\r\n\t$blog = Blog::findOne($blog_id);\r\n\t// stash() lets you store stuff for later use (NOT a cache)\r\n\tstash('blog', $blog);\r\n});\r\n\r\n// here, we have :blog_id in the route, so our preloader gets run\r\nget('/blogs/:blog_id', function ($blog_id) {\r\n\t// pick up what we got from the stash\r\n\t$blog = stash('blog');\r\n\trender('blogs/show', array('blog' => $blog);\r\n});\r\n?>\r\n```\r\n\r\n## Before and After Callbacks\r\nDispatch also lets you setup routines that can be called before or after requests are handled.\r\n\r\n```php\r\n<?php\r\n// setup a function to be called before each request\r\nbefore(function () {\r\n  // do something...\r\n  // maybe setup the DB?\r\n});\r\n\r\n// setup a function to be called after each request\r\nafter(function () {\r\n  // clean up stuff\r\n  // close connections\r\n  // etc\r\n});\r\n```\r\n\r\n## Views and Partials\r\nDispatch gives you two functions for displaying views or templates and for loading view segments or partials - `render()` and `partial()`. When you call these functions, Dispatch looks for the filenames you pass to it inside the path you set `views.root` to. The view files need to have the `.html.php` extensions. For partials, the filenames need to begin with the underscore (_).\r\n\r\n```php\r\n<?php\r\n// this echos the contents of the templates, using the values\r\n// passed to it as locals in the template's scope\r\nrender('users/profile', array('name' => 'jaydee', 'age' => 35));\r\n\r\n// by default, render uses a file called 'layout.html.php' as it's layout file.\r\n// to use a different one, pass the filename as the third argument (minues the extension)\r\nrender('users/profile', null, 'custom_layout');\r\n\r\n// if you're trying to dump jason data, you can skip a layout file by setting it to false\r\nrender('users/profile.json', null, false);\r\n\r\n// partial files have filenames prefixed with the underscore (_). you don't need to\r\n// put in the underscore when loading them\r\n$html = partial('users/profile_links', array('data' => $data));\r\n```\r\n\r\n## Configurations\r\nYou can make use of ini files for configuration by doing something like `config('source', 'myconfig.ini')`.\r\nThis lets you put configuration settings in ini files instead of making `config()` calls in your code.\r\n\r\n```php\r\n<?php\r\n// load the contents of my-settings.ini into config()\r\nconfig('source', 'my-settings.ini');\r\n\r\n// set a different folder for the views\r\nconfig('views.root', __DIR__.'/myviews');\r\n\r\n// get the encryption secret\r\n$secret = config('cookies.secret');\r\n?>\r\n```\r\n\r\n## Caching via APC\r\nIf you have `apc.so` enabled, you can make use of dispatch's simple caching functions.\r\n\r\n```php\r\n<?php\r\n// fetch something from the cache (ttl param is 60)\r\n$data = cache('users', function () {\r\n  // this function is called as a loader if apc\r\n  // doesn't have 'users' in the cache, whatever\r\n  // it returns gets stored into apc and mapped to\r\n  // the 'users' key\r\n  return array('sheryl', 'addie', 'jaydee');\r\n}, 60);\r\n\r\n// invalidate our cached keys (users, products, news)\r\ncache_invalidate('users', 'products', 'news');\r\n```\r\n\r\n## Utility Functions\r\nThere are a lot of other useful routines in the library. Documentation is still lacking but they're very small and easy to figure out. Read the source for now.\r\n\r\n```php\r\n<?php\r\n// store a config and get it\r\nconfig('views.root', './views');\r\nconfig('views.root'); // returns './views'\r\n\r\n// stash a var and get it (useful for moving stuff between scopes)\r\nstash('user', $user);\r\nstash('user'); // returns stored $user var\r\n\r\n// redirect with a status code\r\nredirect(302, '/index');\r\n\r\n// redirect if a condition is met\r\nredirect(403, '/users', !$authenticated);\r\n\r\n// redirect only if func is satisfied\r\nredirect('/admin', function () use ($auth) { return !!$auth; });\r\n\r\n// redirect only if func is satisfied, and with a diff code\r\nredirect(301, '/admin', function () use ($auth) { return !!$auth; });\r\n\r\n// send a http error code and print out a message\r\nerror(403, 'Forbidden');\r\n\r\n// get the current HTTP method or check the current method\r\nmethod(); // GET, POST, PUT, DELETE\r\nmethod('POST'); // true if POST request, false otherwise\r\n\r\n// client's IP\r\nclient_ip();\r\n\r\n// get a value from $_POST, returns null if not set\r\n$name = from($_POST, 'name');\r\n\r\n// create an associative array using the passed keys,\r\n// pulling the values from $_POST\r\n$user = from($_POST, array('username', 'email', 'password'));\r\n\r\n// try to get a value from $_GET, use a default value if not set\r\n$user = from($_GET, 'username', 'Sranger');\r\n\r\n// set a flash message\r\nflash('error', 'Invalid username');\r\n\r\n// in a subsequent request, get the flash message\r\n$error = flash('error');\r\n\r\n// escape a string\r\n_h('Marley & Me');\r\n\r\n// url encode\r\n_u('http://noodlehaus.github.com/dispatch');\r\n\r\n// load a partial using some file and locals\r\n$html = partial('users/profile', array('user' => $user));\r\n?>\r\n```\r\n\r\n## Related Libraries\r\n* [disptach-mongo](http://github.com/noodlehaus/dispatch-mongo) - wrapper for commonly used mongodb functions for dispatch\r\n* [disptach-elastic](http://github.com/noodlehaus/dispatch-elastic) - wrapper for commonly used elasticsearch operations for dispatch\r\n\r\n## Credits\r\n\r\nThe following projects served as both references and inspirations for Dispatch:\r\n\r\n* [ExpressJS](http://expressjs.com)\r\n* [Sinatra](http://sinatrarb.com)\r\n* [BreezePHP](http://breezephp.com)\r\n\r\nThanks to the following contributors for helping improve this tool :)\r\n\r\n* Kafene [kafene](https://github.com/kafene)\r\n* Martin Angelov [martingalv](https://github.com/martinaglv)\r\n* Lars [larsbo](https://github.com/larsbo)\r\n\r\n## LICENSE\r\nMIT http://noodlehaus.mit-license.org/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}