{"name":"Dispatch","tagline":"dispatch php 5.3 utility library","body":"Dispatch PHP 5.3+ Micro-framework\r\n=================================\r\nDispatch is a PHP micro-framework. It provides 29 short and easy functions that wrap commonly-used tasks in creating a web app. At the very least, Dispatch provides you with URL routing and view rendering.\r\n\r\n## Requirements\r\n* PHP 5.3+\r\n* `mcrypt` extension if you want to use encrypted cookies and wish to use `encrypt()` and `decrypt()` functions\r\n* `apc` extension if you want to use `cache()` and `cache_invalidate()`\r\n\r\n## Installation\r\nDispatch can be installed by using `composer`. In your `composer.json` file, do the following:\r\n\r\n```javascript\r\n{\r\n  \"require\": {\r\n    \"php\": \">= 5.3.0\",\r\n    ...\r\n    \"dispatch/dispatch\": \"dev-master\"\r\n  }\r\n}\r\n```\r\n\r\nAfter adding the appropriate `require` entries, do a `composer install` or `composer update` to install the package.\r\n\r\nIf you don't use `composer`, you can download and include [src/dispatch.php](https://github.com/noodlehaus/dispatch/raw/master/src/dispatch.php) directly in your application.\r\n\r\nNote that Dispatch functions are all loaded into the global namespace.\r\n\r\n## Configuration Variables\r\n\r\nCertain properties and behaviours of Dispatch can be configured via the following `config()` entries:\r\n\r\n* `config('source', 'inifile.ini')` makes the contents of `inifile.ini` accessible via `config()` calls\r\n* `config('routing.base', 'string/to/strip')` lets you specify a string to strip from the URI before routing\r\n* `config('views.root')` is used by `render()` and `partial()`, defaults to `./views`\r\n* `config('views.layout')` is used by `render()`, defaults to `layout`\r\n* `config('cookies.secret')` encryption salt to be used by `encrypt()`, `decrypt()`, `set_cookie()` and `get_cookie()`\r\n* `config('cookies.flash')` cookie name to be used by `flash()` for setting messages\r\n\r\n## Quick and Basic\r\nA typical PHP app using dispatch() will look like this.\r\n\r\n```php\r\n<?php\r\n// include the library\r\ninclude 'dispatch.php';\r\n\r\n// define your routes\r\nget('/greet', function () {\r\n\t// render a view\r\n\trender('greet-form');\r\n});\r\n\r\n// post handler\r\npost('/greet', function () {\r\n\t$name = from($_POST, 'name');\r\n\t// render a view while passing some locals\r\n\trender('greet-show', array('name' => $name));\r\n});\r\n\r\n// put handler\r\nput('/users', function () {\r\n  // ...\r\n});\r\n\r\n// delete handler\r\ndelete('/users/:id', function ($id) {\r\n  // ...\r\n});\r\n\r\n// serve your site\r\ndispatch();\r\n?>\r\n```\r\n\r\n## URI Rewriting and Stripping\r\nSetting `routing.base` to a string will strip that string from the URI before it is routed. Two use cases for this are when you don't have access to URI rewriting on your server, and if your dispatch application resides in a subdirectory.\r\n\r\n```php\r\n<?php\r\n// example 1: want to strip the index.php part from the URI\r\nconfig('routing.base', 'index.php');\r\n\r\nget('/users', function () {\r\n  echo \"listing users...\";\r\n});\r\n\r\n// requested URI = /index.php/users\r\n// response = \"listing users...\"\r\n\r\n// example 2: our app lives in /mysite\r\nconfig('routing.base', 'mysite');\r\n\r\nget('/users', function () {\r\n  echo \"listing users...\";\r\n});\r\n\r\n// requested URI = /mysite/users\r\n// response = \"listing users...\"\r\n?>\r\n```\r\n\r\n## RESTful Resources\r\nIf you have a class that supports all or some of the default REST actions, you can easily publish them using `restify()`. By default, `restify()` will create all REST routes for your class. You can selectively publish actions by passing them to the function. To make a class support `restify()`, you need to implement some or all of the following methods:\r\n\r\n* `onIndex` - for the resource list\r\n* `onNew` - for the resource creation form\r\n* `onCreate` - for the creation action\r\n* `onShow($id)` - for viewing a resource\r\n* `onEdit($id)` - for the resource edit form\r\n* `onUpdate($id)` - for the resource edit action\r\n* `onDelete($id)` - for the resource delete action\r\n\r\nNote that the routes published by `restify()` uses the symbol `:id` to identify the resource.\r\n\r\n```php\r\n// resource to publish\r\nclass Users {\r\n  public function onIndex() {}\r\n  public function onNew() {}\r\n  public function onCreate() {}\r\n  public function onShow($id) {}\r\n  public function onEdit($id) {}\r\n  public function onUpdate($id) {}\r\n  public function onDelete($id) {}\r\n}\r\n\r\n// publish the instance, with all endpoints, under /users\r\nrestify('/users', new Users());\r\n\r\n// resource with just some of the REST endpoints\r\nclass Pages {\r\n  public function onIndex() {\r\n    echo \"Pages::onIndex\\n\";\r\n  }\r\n  public function onShow($id) {\r\n    echo \"Pages::onShow {$id}\\n\";\r\n  }\r\n}\r\n\r\n// publish object under /pages, but with just the available actions\r\nrestify('/pages', new Pages(), array('index', 'show'));\r\n?>\r\n```\r\n\r\n## Route Symbol Filters\r\nThis is taken from ExpressJS. Route filters let you map functions against symbols in your routes. These functions then get executed when those symbols are matched.\r\n\r\n```php\r\n<?php\r\n// preload blog entry whenever a matching route has :blog_id in it\r\nfilter('blog_id', function ($blog_id) {\r\n\t$blog = Blog::findOne($blog_id);\r\n\t// stash() lets you store stuff for later use (NOT a cache)\r\n\tstash('blog', $blog);\r\n});\r\n\r\n// here, we have :blog_id in the route, so our preloader gets run\r\nget('/blogs/:blog_id', function ($blog_id) {\r\n\t// pick up what we got from the stash\r\n\t$blog = stash('blog');\r\n\trender('blogs/show', array('blog' => $blog);\r\n});\r\n?>\r\n```\r\n\r\n## Caching via APC\r\nIf you have `apc.so` enabled, you can make use of dispatch's simple caching functions.\r\n\r\n```php\r\n<?php\r\n// fetch something from the cache (ttl param is 60)\r\n$data = cache('users', function () {\r\n  // this function is called as a loader if apc\r\n  // doesn't have 'users' in the cache, whatever\r\n  // it returns gets stored into apc and mapped to\r\n  // the 'users' key\r\n  return array('sheryl', 'addie', 'jaydee');\r\n}, 60);\r\n\r\n// invalidate our cached keys (users, products, news)\r\ncache_invalidate('users', 'products', 'news');\r\n```\r\n\r\n## Configurations\r\nYou can make use of ini files for configuration by doing something like `config('source', 'myconfig.ini')`.\r\nThis lets you put configuration settings in ini files instead of making `config()` calls in your code.\r\n\r\n```php\r\n<?php\r\n// load the contents of my-settings.ini into config()\r\nconfig('source', 'my-settings.ini');\r\n\r\n// set a different folder for the views\r\nconfig('views.root', __DIR__.'/myviews');\r\n\r\n// get the encryption secret\r\n$secret = config('cookies.secret');\r\n?>\r\n```\r\n\r\n## Utility Functions\r\nThere are a lot of other useful routines in the library. Documentation is still lacking but they're very small and easy to figure out. Read the source for now.\r\n\r\n```php\r\n<?php\r\n// store a config and get it\r\nconfig('views.root', './views');\r\nconfig('views.root'); // returns './views'\r\n\r\n// stash a var and get it (useful for moving stuff between scopes)\r\nstash('user', $user);\r\nstash('user'); // returns stored $user var\r\n\r\n// redirect with a status code\r\nredirect(302, '/index');\r\n\r\n// redirect if a condition is met\r\nredirect(403, '/users', !$authenticated);\r\n\r\n// redirect only if func is satisfied\r\nredirect('/admin', function () use ($auth) { return !!$auth; });\r\n\r\n// redirect only if func is satisfied, and with a diff code\r\nredirect(301, '/admin', function () use ($auth) { return !!$auth; });\r\n\r\n// send a http error code and print out a message\r\nerror(403, 'Forbidden');\r\n\r\n// get the current HTTP method or check the current method\r\nmethod(); // GET, POST, PUT, DELETE\r\nmethod('POST'); // true if POST request, false otherwise\r\n\r\n// client's IP\r\nclient_ip();\r\n\r\n// get a value from $_POST, returns null if not set\r\n$name = from($_POST, 'name');\r\n\r\n// create an associative array using the passed keys,\r\n// pulling the values from $_POST\r\n$user = from($_POST, array('username', 'email', 'password'));\r\n\r\n// try to get a value from $_GET, use a default value if not set\r\n$user = from($_GET, 'username', 'Sranger');\r\n\r\n// set a flash message\r\nflash('error', 'Invalid username');\r\n\r\n// in a subsequent request, get the flash message\r\n$error = flash('error');\r\n\r\n// escape a string\r\n_h('Marley & Me');\r\n\r\n// url encode\r\n_u('http://noodlehaus.github.com/dispatch');\r\n\r\n// load a partial using some file and locals\r\n$html = partial('users/profile', array('user' => $user));\r\n?>\r\n```\r\n\r\n## Related Libraries\r\n* [disptach-mongo](http://github.com/noodlehaus/dispatch-mongo) - wrapper for commonly used mongodb functions for dispatch\r\n* [disptach-elastic](http://github.com/noodlehaus/dispatch-elastic) - wrapper for commonly used elasticsearch operations for dispatch\r\n\r\n## Credits\r\n\r\nThe following projects served as both references and inspirations for Dispatch:\r\n\r\n* [ExpressJS](http://expressjs.com)\r\n* [Sinatra](http://sinatrarb.com)\r\n* [BreezePHP](http://breezephp.com)\r\n\r\nThanks to the following contributors for helping improve this tool :)\r\n\r\n* Kafene [kafene](https://github.com/kafene)\r\n* Martin Angelov [martingalv](https://github.com/martinaglv)\r\n* Lars [larsbo](https://github.com/larsbo)\r\n\r\n## LICENSE\r\nMIT http://noodlehaus.mit-license.org/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}